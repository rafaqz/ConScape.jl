# Landmark function for testing purposes

```julia
nothing
using ConScape, Rasters, ArchGDAL, SparseArrays, LinearAlgebra, Plots
```

```julia
gridplus=10
```

```julia
grid = 10
```

# Data import and Grid creation

```julia
datadir = joinpath(dirname(pathof(ConScape)), "..", "data")
```

```julia
mov_prob = replace_missing(Raster(joinpath(datadir, "mov_prob_1000.asc")), NaN)
hab_qual = replace_missing(Raster(joinpath(datadir, "hab_qual_1000.asc")), NaN);
```

```julia
non_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))
mov_prob[non_matches] .= 1e-20
hab_qual[non_matches] .= 1e-20;
```

```julia
g = ConScape.Grid(size(mov_prob)...,
                      affinities=ConScape.graph_matrix_from_raster(mov_prob),
                      qualities=hab_qual,
                      costs=ConScape.MinusLog())
```

# Coarse graining

```julia
g_coarse = ConScape.Grid(size(mov_prob)...,
                         affinities=ConScape.graph_matrix_from_raster(mov_prob),
                         source_qualities=hab_qual,
                         target_qualities=ConScape.coarse_graining(g, 20),
                         costs=ConScape.MinusLog());
```

```julia
theta = 1.0
```

```julia
theta = 0.01
```

```julia
@time h = ConScape.GridRSP(g, θ=theta);
```

```julia
@time h_coarse = ConScape.GridRSP(g_coarse, θ=theta);
```

```julia
func = @time ConScape.connected_habitat(h, distance_transformation=x -> exp(-x/75))
func_coarse = @time ConScape.connected_habitat(h_coarse, distance_transformation=x -> exp(-x/75));
```

```julia
sum(t -> isnan(t) ? 0.0 : t, func_coarse)/sum(t -> isnan(t) ? 0.0 : t, func)
```

```julia
using Statistics
cor(filter(!isnan, func), filter(!isnan, func_coarse))
```

```julia
qbetw = ConScape.betweenness_qweighted(h);
heatmap(qbetw)
```

```julia
qbetw_coarse = ConScape.betweenness_qweighted(h_coarse);
heatmap(qbetw_coarse)
```

```julia
cor(filter(!isnan, qbetw), filter(!isnan, qbetw_coarse))
```

```julia
kbetw = @time ConScape.betweenness_kweighted(h, distance_transformation=x -> exp(-x/75));
kbetw_coarse = @time ConScape.betweenness_kweighted(h_coarse, distance_transformation=x -> exp(-x/75));
```

```julia
cor(filter(!isnan, kbetw), filter(!isnan, kbetw_coarse))
```

We can write this using a lazy problem definition:

```julia
# Put least cost, random walk, and rsp
problem = ConScape.Problem(; 
    graph_measures = (;
        func=ConScape.ConnectedHabitat(),
        qbetw=ConScape.BetweennessQweighted(),
        kbetw=ConScape.BetweennessKweighted(),
    ),
    connectivity_measure=ConScape.ExpectedCost(
        θ=1.0, 
        distance_transformation = (exp=x -> exp(-x/75), oddsfor=ConScape.OddsFor())
    ),
    solver=ConScape.MatrixSolver(),
    # solver=ConScape.VectorSolver(nothing),
)
```

Then run it for all operations on both normal and coarse grids

```julia
rast = RasterStack((; affinities=mov_prob, qualities=hab_qual))
rast_coarse = ConScape.coarse_graining(rast, 20)
result = ConScape.solve(problem, rast)
result_coarse = ConScape.solve(problem, rast_coarse)
```

We can plot these outputs:
```julia
heatmap(result.qbetw_oddsfor)
heatmap(result_coarse.qbetw_oddsfor)
heatmap(result.qbetw_exp)
heatmap(result_coarse.qbetw_exp)
heatmap(result.kbetw_exp)
heatmap(result_coarse.kbetw_exp)
heatmap(result.func_exp)
heatmap(result.coarse_func_exp)
```


```julia
windowed_problem = ConScape.WindowedProblem(problem; 
    radius=20, overlap=5, threaded=true
)
@time result = ConScape.solve(windowed_problem, rast)
plot(result)
plot(result.func_exp)
```


```julia
stored_problem = ConScape.StoredProblem(problem; 
    path=".", radius=20, overlap=30, threaded=true
)
ConScape.solve(stored_problem, rast)
result = mosaic(stored_problem; to=rast)
plot(result)
plot(result.func_exp)

# Calculate job ids to run on a cluster
jobs = ConScape.batch_ids(stored_problem, rast)
```

And we can check the corelation similarly to above, by getting
layers from `res` and `res_coarse`
```julia
cor(filter(!isnan, res.qbetw.oddsfor), filter(!isnan, res_coarse.qbetw.oddsfor))
cor(filter(!isnan, res.qbetw.oddsfor), filter(!isnan, res_coarse.qbetw.oddsfor))
cor(filter(!isnan, res.kbetw.oddsfor), filter(!isnan, res_coarse.kbetw.oddsfor))
cor(filter(!isnan, res.kbetw.exp), filter(!isnan, res_coarse.kbetw.exp))
cor(filter(!isnan, res.func.exp), filter(!isnan, res_coarse.func.exp))
```

# Test landmark performance for amount of connected habitat

```julia
coarseness = (1,2,3,5,7,10,15,20)

tmp = map(1:length(coarseness)) do i
    g_coarse = ConScape.Grid(size(mov_prob)...,
        affinities=ConScape.graph_matrix_from_raster(mov_prob),
        source_qualities=hab_qual,
        target_qualities=ConScape.coarse_graining(g, coarseness[i]),
        costs=ConScape.MinusLog(), );

    h_coarse = @time ConScape.GridRSP(g_coarse, θ=theta);
    func_coarse = ConScape.connected_habitat(h_coarse, distance_transformation=x -> exp(-x/75));

    (
        sum(t -> isnan(t) ? 0.0 : t, func_coarse),
        cor(filter(!isnan, func), filter(!isnan, func_coarse))
    )
end

est_func = first.(tmp)
cor_func = last.(tmp);
```

```julia
sum_func = sum(t -> isnan(t) ? 0.0 : t, func)
plot(est_func/sum_func)
```

```julia
est_func/sum_func
```

```julia
plot(cor_func)
```

```julia
cor_func
```

# Test landmark performance for movement flow

## Quality weighted

```julia
cor_qbetw = map(1:length(coarseness)) do i
    g_coarse = ConScape.Grid(size(mov_prob)...,
        affinities=ConScape.graph_matrix_from_raster(mov_prob),
        source_qualities=hab_qual,
        target_qualities=ConScape.coarse_graining(g, coarseness[i]),
        costs=ConScape.MinusLog(), );

    h_coarse = @time ConScape.GridRSP(g_coarse, θ=theta);
    qbetw_coarse = ConScape.betweenness_qweighted(h_coarse);

    return cor(filter(!isnan, qbetw), filter(!isnan, qbetw_coarse))
end
```

```julia
plot(cor_qbetw)
```

```julia
cor_qbetw
```

## Proximity weighted

```julia
cor_kbetw = map(1:length(coarseness))do i
    g_coarse = ConScape.Grid(size(mov_prob)...,
        affinities=ConScape.graph_matrix_from_raster(mov_prob),
        source_qualities=hab_qual,
        target_qualities=ConScape.coarse_graining(g, coarseness[i]),
        costs=ConScape.MinusLog());

    @time h_coarse = ConScape.GridRSP(g_coarse, θ=theta);
    kbetw_coarse = ConScape.betweenness_kweighted(h_coarse, distance_transformation=x -> exp(-x/75));

    return cor(filter(!isnan, kbetw), filter(!isnan, kbetw_coarse))
end
```

```julia
plot(cor_kbetw)
```

```julia
cor_kbetw
```

# Figures for the paper

```julia
plot(Array[cor_func, cor_qbetw, cor_kbetw],  title = "Correlation",
    xlabel = "Coarseness",
    xticks = (1:8, coarseness),
    label = ["Amount Connected Habitat" "Quality-weighted Movement Flow" "Proximity-weighted Movement Flow"],
    legend=:bottomleft,
    lw = 3)
#savefig("output_figures/figure_lm_cors.png")
```

```julia
s
plot(est_func/sum_func,  title = "Estimated Amount Connected Habitat",
    xlabel = "Coarseness",
    xticks = (1:8, coarseness),
    legend=false,
    lw = 3)
#savefig("output_figures/figure_lm_conhab.png")
```

```julia
plot((est_func .- sum_func)/sum_func*100,  title = "% Underestimation of the landscape's Connected Habitat",
    xlabel = "Coarseness",
    xticks = (1:8, coarseness),
    legend=false,
    lw = 3)
# savefig("output_figures/figure_lm_conhab.png")
```

```julia
(est_func .- sum_func)/sum_func*100
```

```julia
g_coarse = ConScape.Grid(size(mov_prob)...,
    affinities=ConScape.graph_matrix_from_raster(mov_prob),
    qualities=hab_qual);
ConScape.coarse_graining(g_coarse, 5)
```
